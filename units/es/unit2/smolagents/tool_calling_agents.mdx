<CourseFloatingBanner chapter={2}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/agents-course/blob/main/notebooks/unit2/smolagents/tool_calling_agents.ipynb"},
]} />

# Escribiendo acciones como fragmentos de cÃ³digo o estructuras JSON

<Tip>
Puedes seguir el cÃ³digo en <a href="https://huggingface.co/agents-course/notebooks/blob/main/unit2/smolagents/tool_calling_agents.ipynb" target="_blank">este notebook</a> que puedes ejecutar usando Google Colab.
</Tip>

Los Agentes de Llamada a Herramientas son el segundo tipo de agente disponible en `smolagents`. A diferencia de los Agentes de CÃ³digo que utilizan fragmentos de Python, estos agentes **utilizan las capacidades integradas de llamada a herramientas de los proveedores de LLM** para generar llamadas a herramientas como **estructuras JSON**. Este es el enfoque estÃ¡ndar utilizado por OpenAI, Anthropic y muchos otros proveedores.

Veamos un ejemplo. Cuando Alfred quiere buscar servicios de catering e ideas para fiestas, un `CodeAgent` generarÃ­a y ejecutarÃ­a cÃ³digo Python como este:

```python
for query in [
    "Mejores servicios de catering en Ciudad GÃ³tica", 
    "Ideas de temas de fiesta para superhÃ©roes"
]:
    print(web_search(f"Buscar: {query}"))
```

Un `ToolCallingAgent` en cambio crearÃ­a una estructura JSON:

```python
[
    {"name": "web_search", "arguments": "Mejores servicios de catering en Ciudad GÃ³tica"},
    {"name": "web_search", "arguments": "Ideas de temas de fiesta para superhÃ©roes"}
]
```

Esta estructura JSON se utiliza luego para ejecutar las llamadas a herramientas.

Aunque `smolagents` se centra principalmente en `CodeAgents` ya que [tienen un mejor rendimiento general](https://huggingface.co/papers/2402.01030), los `ToolCallingAgents` pueden ser efectivos para sistemas simples que no requieren manejo de variables o llamadas a herramientas complejas.

![Acciones de CÃ³digo vs JSON](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/code_vs_json_actions.png)  

## Â¿CÃ³mo Funcionan los Agentes de Llamada a Herramientas?  

Los Agentes de Llamada a Herramientas siguen el mismo flujo de trabajo de mÃºltiples pasos que los Agentes de CÃ³digo (consulta la [secciÃ³n anterior](./code_agents) para mÃ¡s detalles). 

La diferencia clave estÃ¡ en **cÃ³mo estructuran sus acciones**: en lugar de cÃ³digo ejecutable, **generan objetos JSON que especifican nombres de herramientas y argumentos**. El sistema luego **analiza estas instrucciones** para ejecutar las herramientas apropiadas.

## Ejemplo: Ejecutando un Agente de Llamada a Herramientas  

Revisemos el ejemplo anterior donde Alfred comenzÃ³ los preparativos de la fiesta, pero esta vez usaremos un `ToolCallingAgent` para destacar la diferencia. Construiremos un agente que pueda buscar en la web usando DuckDuckGo, al igual que en nuestro ejemplo de Agente de CÃ³digo. La Ãºnica diferencia es el tipo de agente - el framework se encarga de todo lo demÃ¡s:

```python
from smolagents import ToolCallingAgent, DuckDuckGoSearchTool, InferenceClientModel

agent = ToolCallingAgent(tools=[DuckDuckGoSearchTool()], model=InferenceClientModel())

agent.run("Busca las mejores recomendaciones de mÃºsica para una fiesta en la mansiÃ³n Wayne.")
```

Cuando examines el rastro del agente, en lugar de ver `Executing parsed code:`, verÃ¡s algo como:

```text
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Llamando a herramienta: 'web_search' con argumentos: {'query': "mejores recomendaciones de mÃºsica para una      â”‚
â”‚ fiesta en la mansiÃ³n Wayne"}                                                                                    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```  

El agente genera una llamada a herramienta estructurada que el sistema procesa para producir la salida, en lugar de ejecutar directamente cÃ³digo como un `CodeAgent`.

Ahora que entendemos ambos tipos de agentes, podemos elegir el adecuado para nuestras necesidades. Â¡Continuemos explorando `smolagents` para hacer que la fiesta de Alfred sea un Ã©xito! ðŸŽ‰

## Recursos

- [DocumentaciÃ³n de ToolCallingAgent](https://huggingface.co/docs/smolagents/v1.8.1/en/reference/agents#smolagents.ToolCallingAgent) - DocumentaciÃ³n oficial para ToolCallingAgent
