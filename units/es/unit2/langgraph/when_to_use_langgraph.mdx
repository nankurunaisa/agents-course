# ¬øQu√© es `LangGraph`?

`LangGraph` s un marco de trabajo desarrollado por [LangChain](https://www.langchain.com/) **para gestionar el flujo de control de aplicaciones que integran un LLM.**.

## ¬øEs `LangGraph` diferente de `LangChain`?

LangChain proporciona una interfaz est√°ndar para interactuar con modelos y otros componentes, √∫til para recuperaci√≥n, llamadas a LLM y llamadas a herramientas.
Las clases de LangChain pueden utilizarse en LangGraph, pero NO TIENEN que ser utilizadas.

Los paquetes son diferentes y pueden usarse de forma aislada, pero, al final, todos los recursos que encontrar√°s en l√≠nea utilizan ambos paquetes de la mano.

## ¬øCu√°ndo deber√≠a usar `LangGraph`?
### Control vs libertad

Al dise√±ar aplicaciones de IA, te enfrentas a un equilibrio fundamental entre **control** y **libertad**:

- **libertad** da a tu LLM m√°s espacio para ser creativo y abordar problemas inesperados.
- **Control** te permite asegurar un comportamiento predecible y mantener barreras de protecci√≥n.

Los Agentes de C√≥digo, como los que puedes encontrar en *smolagents*,son muy libres. Pueden llamar a m√∫ltiples herramientas en un solo paso de acci√≥n, crear sus propias herramientas, etc. Sin embargo, este comportamiento puede hacerlos menos predecibles y menos controlables que un Agente regular trabajando con JSON.

`LangGraph` est√° en el otro extremo del espectro, brilla cuando necesitas **"Control"** sobre la ejecuci√≥n de tu agente.

LangGraph es particularmente valioso cuando necesitas **Control sobre tus aplicaciones**.  Te da las herramientas para construir una aplicaci√≥n que siga un proceso predecible mientras aprovecha el poder de los LLMs. 

En t√©rminos simples, si tu aplicaci√≥n involucra una serie de pasos que necesitan ser orquestados de una manera espec√≠fica, con decisiones siendo tomadas en cada punto de uni√≥n, **LangGraph proporciona la estructura que necesitas**.

Como ejemplo, digamos que queremos construir un asistente LLM que pueda responder algunas preguntas sobre algunos documentos.

Como los LLMs entienden mejor el texto, antes de poder responder a la pregunta, necesitar√°s convertir otras modalidades complejas (gr√°ficos, tablas) en texto. Sin embargo, ¬°esa elecci√≥n depende del tipo de documento que tengas!

Esta es una ramificaci√≥n que eleg√≠ representar de la siguiente manera: 

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/flow.png" alt="Control flow"/>

> üí° **Tip:**  La parte izquierda no es un agente, ya que aqu√≠ no est√° involucrada ninguna llamada a herramientas. Pero la parte derecha necesitar√° escribir algo de c√≥digo para consultar el xls (convertir a pandas y manipularlo).

Si bien esta ramificaci√≥n es determinista, tambi√©n puedes dise√±ar ramificaciones que est√©n condicionadas por la salida de un LLM, haci√©ndolas indeterministas.

Los escenarios clave donde LangGraph sobresale incluyen:

- **Procesos de razonamiento en m√∫ltiples pasos** que necesitan control expl√≠cito sobre el flujo
- **Aplicaciones que requieren persistencia de estado** entre pasos
- **Sistemas que combinan l√≥gica determinista con capacidades de IA**
- **Flujos de trabajo que necesitan intervenciones humanas en el ciclo**
- **Arquitecturas de agentes complejas ** con m√∫ltiples componentes trabajando juntos

En esencia, siempre que sea posible, ** como humano**, dise√±a un flujo de acciones basado en la salida de cada acci√≥n, y decide qu√© ejecutar a continuaci√≥n en consecuencia. En este caso, ¬°LangGraph es el marco de trabajo correcto para ti!

`LangGraph` es, en mi opini√≥n, el marco de trabajo de agentes m√°s listo para producci√≥n en el mercado.

## ¬øC√≥mo funciona LangGraph?

En su esencia,  `LangGraph` utiliza una estructura de grafo dirigido para definir el flujo de tu aplicaci√≥n:

- **Nodos** representan pasos de procesamiento individuales (como llamar a un LLM, usar una herramienta o tomar una decisi√≥n).
- **Aristas(Edges)** definen las posibles transiciones entre pasos.
- **Estado** es definido por el usuario, se mantiene y se pasa entre nodos durante la ejecuci√≥n. Al decidir qu√© nodo dirigir a continuaci√≥n, este es el estado actual que observamos.

¬°Exploraremos estos bloques fundamentales m√°s en el pr√≥ximo cap√≠tulo!

## ¬øEn qu√© se diferencia de Python regular? ¬øPor qu√© necesito LangGraph?

Te preguntaras : "Podr√≠a simplemente escribir c√≥digo Python regular con declaraciones if-else para manejar todos estos flujos, ¬øverdad?" 

Aunque t√©cnicamente es cierto, LangGraph ofrece **algunas ventajas ** osobre Python puro para construir sistemas complejos. Podr√≠as construir la misma aplicaci√≥n sin LangGraph, pero proporciona herramientas y abstracciones m√°s f√°ciles para ti.

Incluye estados, visualizaci√≥n, registro (trazas), integraci√≥n de humanos en el ciclo incorporada, y m√°s.